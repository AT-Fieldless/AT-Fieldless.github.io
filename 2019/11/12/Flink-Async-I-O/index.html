<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Flink Async I/O"><meta name="keywords" content="Flink, Mr.Thirteen's blog"><link rel="alternate" href="/default" title="Mr.Thirteen's blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="https://at-fieldless.github.io/2019/11/12/Flink-Async-I-O/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":"app_id:Ft6e3NGMakjJA8863I2S0Njs-gzGzoHsz app_key:0FzGh29Jey21Jw3XXnTI4TvJ","toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>Flink Async I/O - Mr.Thirteen's blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Mr.Thirteen's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Mr.Thirteen's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Flink Async I/O
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-11-12
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么需要Flink-Async-I-O"><span class="toc-text">为什么需要Flink Async I/O</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Flink-是怎么设计-Aysnc-I-O的？"><span class="toc-text">Flink 是怎么设计 Aysnc I/O的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AsyncWaitOperator-处理流程"><span class="toc-text">AsyncWaitOperator 处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#processElement"><span class="toc-text">processElement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#addAsyncBufferEntry"><span class="toc-text">addAsyncBufferEntry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#有序队列"><span class="toc-text">有序队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addEntry"><span class="toc-text">addEntry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onCompleteHandler"><span class="toc-text">onCompleteHandler</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无序队列"><span class="toc-text">无序队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addEntry-1"><span class="toc-text">addEntry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onCompleteHandler-1"><span class="toc-text">onCompleteHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Emitter"><span class="toc-text">Emitter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#run"><span class="toc-text">run</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结语"><span class="toc-text">结语</span></a></li></ol>
    </div>
  </div><div class="post-content"><h1 id="为什么需要Flink-Async-I-O"><a href="#为什么需要Flink-Async-I-O" class="headerlink" title="为什么需要Flink Async I/O"></a>为什么需要Flink Async I/O</h1><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.9/fig/async_io.svg" alt="Async I/O与传统I/O的区别"></p>
<p>对于传统的阻塞I/O来说，每次和数据库进行一次就会被堵塞，下一次的I/O请求得等到上一次的完成才能发出，这对于流式系统的性能影响是很大的。</p>
<p>而如果像图中所示，通过异步I/O的方式，并发得发出多个请求，这样就可以把一次请求的时间平摊到多个请求中了。</p>
<!-- # Flink Async I/O 架构 -->
<!-- ![架构图](https://cwiki.apache.org/confluence/download/attachments/65870673/future-wait-operator.jpg?version=1&modificationDate=1474192093000&api=v2)

![AsyncCollectorBuffer架构图](https://cwiki.apache.org/confluence/download/attachments/65870673/async-task-buffer.jpg?version=1&modificationDate=1474192804000&api=v2) -->
<a id="more"></a>
<h1 id="Flink-是怎么设计-Aysnc-I-O的？"><a href="#Flink-是怎么设计-Aysnc-I-O的？" class="headerlink" title="Flink 是怎么设计 Aysnc I/O的？"></a>Flink 是怎么设计 Aysnc I/O的？</h1><p>再让我们回到上面这张图，我们可以把右边蓝色的a,b,c,d都看成一个个 CompletableFuture，这么多 CompletableFuture 总得找个地方存吧？最后是不是还得有一个线程无时无刻得看一看这个存储容器里有哪个 CompletableFuture 完成了，好把它输出出去？</p>
<p>Flink 基本上就是按照这三步来设计 Async I/O 的</p>
<ul>
<li>生成一个 CompletableFuture</li>
<li>把这个 CompletableFuture 放入队列中并启动 I/O</li>
<li>通过一个 Emitter 线程不停访问队列，把完成的结果进行输出</li>
</ul>
<p>接下来就通过代码来分析分析这三步。</p>
<h1 id="AsyncWaitOperator-处理流程"><a href="#AsyncWaitOperator-处理流程" class="headerlink" title="AsyncWaitOperator 处理流程"></a>AsyncWaitOperator 处理流程</h1><h2 id="processElement"><a href="#processElement" class="headerlink" title="processElement"></a>processElement</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(StreamRecord&lt;IN&gt; element)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> StreamRecordQueueEntry&lt;OUT&gt; streamRecordBufferEntry = <span class="keyword">new</span> StreamRecordQueueEntry&lt;&gt;(element);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (timeout &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">			<span class="comment">// register a timeout for this AsyncStreamRecordBufferEntry</span></span><br><span class="line">			<span class="keyword">long</span> timeoutTimestamp = timeout + getProcessingTimeService().getCurrentProcessingTime();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> ScheduledFuture&lt;?&gt; timerFuture = getProcessingTimeService().registerTimer(</span><br><span class="line">				timeoutTimestamp,</span><br><span class="line">				<span class="keyword">new</span> ProcessingTimeCallback() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						userFunction.timeout(element.getValue(), streamRecordBufferEntry);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Cancel the timer once we've completed the stream record buffer entry. This will remove</span></span><br><span class="line">			<span class="comment">// the register trigger task</span></span><br><span class="line">			streamRecordBufferEntry.onComplete(</span><br><span class="line">				(StreamElementQueueEntry&lt;Collection&lt;OUT&gt;&gt; value) -&gt; &#123;</span><br><span class="line">					timerFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">				&#125;,</span><br><span class="line">				executor);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		addAsyncBufferEntry(streamRecordBufferEntry);</span><br><span class="line"></span><br><span class="line">		userFunction.asyncInvoke(element.getValue(), streamRecordBufferEntry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>首先生成一个可以放入队列的元素。在放进去之前先获取系统当前时间，再加上用户定义的延迟大小，得到一个任务最迟完成时间，并用这个时间来注册一个计时器。如果超时就调用用户定义的 timeout 方法（Flink默认实现了一个 timeout 函数，用户可以直接用）。当然如果没有超时就需要取消掉它。然后尝试放入到队列中，最后就调用用户自定义的 <code>asyncInvoke</code> 方法，进行异步I/O。</p>
<h2 id="addAsyncBufferEntry"><a href="#addAsyncBufferEntry" class="headerlink" title="addAsyncBufferEntry"></a>addAsyncBufferEntry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAsyncBufferEntry</span><span class="params">(StreamElementQueueEntry&lt;T&gt; streamElementQueueEntry)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">assert</span>(Thread.holdsLock(checkpointingLock));</span><br><span class="line"></span><br><span class="line">		pendingStreamElementQueueEntry = streamElementQueueEntry;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!queue.tryPut(streamElementQueueEntry)) &#123;</span><br><span class="line">			<span class="comment">// we wait for the emitter to notify us if the queue has space left again</span></span><br><span class="line">			checkpointingLock.wait();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pendingStreamElementQueueEntry = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在 Flink Async I/O 中设计了两种不同模式来生成流的结果，一种是有序——输出结果的顺序和该元素进来的顺序是完全一致的，另一种则是无序的。根据模式的不同，自然也就会有两种不同的队列。接下来就会讲这两种队列是如何实现的。</p>
<p>顺道提一下，这个 addAsyncBufferEntry 方法很明显得使用了生产者-消费者模式，队列就是存放生产者存放物品以及消费者消费物品的地方，而 checkpointingLock 则很明显就是那把防止并发访问出错的锁。</p>
<h3 id="有序队列"><a href="#有序队列" class="headerlink" title="有序队列"></a>有序队列</h3><h4 id="addEntry"><a href="#addEntry" class="headerlink" title="addEntry"></a>addEntry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(StreamElementQueueEntry&lt;T&gt; streamElementQueueEntry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">assert</span>(lock.isHeldByCurrentThread());</span><br><span class="line"></span><br><span class="line">		queue.addLast(streamElementQueueEntry);</span><br><span class="line"></span><br><span class="line">		streamElementQueueEntry.onComplete(</span><br><span class="line">			(StreamElementQueueEntry&lt;T&gt; value) -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					onCompleteHandler(value);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// we got interrupted. This indicates a shutdown of the executor</span></span><br><span class="line">					LOG.debug(<span class="string">"AsyncBufferEntry could not be properly completed because the "</span> +</span><br><span class="line">						<span class="string">"executor thread has been interrupted."</span>, e);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">					operatorActions.failOperator(<span class="keyword">new</span> Exception(<span class="string">"Could not complete the "</span> +</span><br><span class="line">						<span class="string">"stream element queue entry: "</span> + value + <span class="string">'.'</span>, t));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			executor);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>很显而易见，有序队列就是把当前元素放到当前队列的最后一个位置，根据队列先进先出的特性保证有序性。</p>
<h4 id="onCompleteHandler"><a href="#onCompleteHandler" class="headerlink" title="onCompleteHandler"></a>onCompleteHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCompleteHandler</span><span class="params">(StreamElementQueueEntry&lt;?&gt; streamElementQueueEntry)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!queue.isEmpty() &amp;&amp; queue.peek().isDone()) &#123;</span><br><span class="line">				LOG.debug(<span class="string">"Signal ordered stream element queue has completed head element."</span>);</span><br><span class="line">				headIsCompleted.signalAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>当元素完成 I/O 任务后，也只是很简单得通知消费者可以消费队列了。</p>
<h3 id="无序队列"><a href="#无序队列" class="headerlink" title="无序队列"></a>无序队列</h3><h4 id="addEntry-1"><a href="#addEntry-1" class="headerlink" title="addEntry"></a>addEntry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(StreamElementQueueEntry&lt;T&gt; streamElementQueueEntry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">assert</span>(lock.isHeldByCurrentThread());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (streamElementQueueEntry.isWatermark()) &#123;</span><br><span class="line">			lastSet = <span class="keyword">new</span> HashSet&lt;&gt;(capacity);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (firstSet.isEmpty()) &#123;</span><br><span class="line">				firstSet.add(streamElementQueueEntry);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Set&lt;StreamElementQueueEntry&lt;?&gt;&gt; watermarkSet = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">				watermarkSet.add(streamElementQueueEntry);</span><br><span class="line">				uncompletedQueue.offer(watermarkSet);</span><br><span class="line">			&#125;</span><br><span class="line">			uncompletedQueue.offer(lastSet);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			lastSet.add(streamElementQueueEntry);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		streamElementQueueEntry.onComplete(</span><br><span class="line">			(StreamElementQueueEntry&lt;T&gt; value) -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					onCompleteHandler(value);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// The accept executor thread got interrupted. This is probably cause by</span></span><br><span class="line">					<span class="comment">// the shutdown of the executor.</span></span><br><span class="line">					LOG.debug(<span class="string">"AsyncBufferEntry could not be properly completed because the "</span> +</span><br><span class="line">						<span class="string">"executor thread has been interrupted."</span>, e);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">					operatorActions.failOperator(<span class="keyword">new</span> Exception(<span class="string">"Could not complete the "</span> +</span><br><span class="line">						<span class="string">"stream element queue entry: "</span> + value + <span class="string">'.'</span>, t));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			executor);</span><br><span class="line"></span><br><span class="line">		numberEntries++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出相对于有序队列，无序队列的实现就复杂了许多。首先介绍其中几个变量。</p>
<ul>
<li>firstSet: 用来存放最早一批没完成 I/O 任务的元素</li>
<li>lastSet：存放最近来到队列没完成 I/O 任务的元素</li>
<li>uncompletedQueue: 里面存的是用 watermarkSet 分割的没完成 I/O 任务的元素集。</li>
<li>completedQueue： 存放完成 I/O 任务的元素（在下个方法中出现）</li>
</ul>
<p>很明显为什么要这么设计的原因自然是因为 watermark 的存在，就算你队列中的元素可以无序，但接收和发送 watermark 还是不能无序的。<br>所以当一个元素来临时，它会先放入lastSet中，但当 watermark 来临时，就代表数据流需要进行分割，之后的数据将会放到新生成的 lastSet 中。</p>
<h4 id="onCompleteHandler-1"><a href="#onCompleteHandler-1" class="headerlink" title="onCompleteHandler"></a>onCompleteHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleteHandler</span><span class="params">(StreamElementQueueEntry&lt;?&gt; streamElementQueueEntry)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (firstSet.remove(streamElementQueueEntry)) &#123;</span><br><span class="line">				completedQueue.offer(streamElementQueueEntry);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (firstSet.isEmpty() &amp;&amp; firstSet != lastSet) &#123;</span><br><span class="line">					firstSet = uncompletedQueue.poll();</span><br><span class="line"></span><br><span class="line">					Iterator&lt;StreamElementQueueEntry&lt;?&gt;&gt; it = firstSet.iterator();</span><br><span class="line"></span><br><span class="line">					<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">						StreamElementQueueEntry&lt;?&gt; bufferEntry = it.next();</span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> (bufferEntry.isDone()) &#123;</span><br><span class="line">							completedQueue.offer(bufferEntry);</span><br><span class="line">							it.remove();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				LOG.debug(<span class="string">"Signal unordered stream element queue has completed entries."</span>);</span><br><span class="line">				hasCompletedEntries.signalAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>而当元素 Async I/O 任务完成时，它就会从 firstSet 中移除并放入 completedQueue 中。如果此时 firstSet 是空的且它不是 lastSet，它就会从 uncompletedQueue 中获取下一个元素集，看看其中有没有任务已经完成了，这时候也体现了为什么它是无序队列了。</p>
<p>相较于有序队列而言，无序队列耗时更少，这也是它的优点之一。</p>
<h2 id="Emitter"><a href="#Emitter" class="headerlink" title="Emitter"></a>Emitter</h2><p>生产了一个 CompletableFuture,而且 CompletableFuture 在队列中也完成了它的 I/O 任务，那么现在就到了第三步也就是最后一步把它从队列中取出来，这个工作就是 Emitter 完成的。</p>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (running) &#123;</span><br><span class="line">				LOG.debug(<span class="string">"Wait for next completed async stream element result."</span>);</span><br><span class="line">				AsyncResult streamElementEntry = streamElementQueue.peekBlockingly();</span><br><span class="line"></span><br><span class="line">				output(streamElementEntry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (running) &#123;</span><br><span class="line">				operatorActions.failOperator(e);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Thread got interrupted which means that it should shut down</span></span><br><span class="line">				LOG.debug(<span class="string">"Emitter thread got interrupted, shutting down."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">			operatorActions.failOperator(<span class="keyword">new</span> Exception(<span class="string">"AsyncWaitOperator's emitter caught an "</span> +</span><br><span class="line">				<span class="string">"unexpected throwable."</span>, t));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Emitter 本身实现了一个 Runnable 接口，在 AsyncWaitOperator 启动的时候，它就被初始化并开始运行，从这个 run 方法我们就可以看出它是无限循环得从队列中取数据，直到被打断。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Flink 就是通过这三步设计了性能如此强大的 Async I/O, 我在 github 上也写了一个 hbase Async I/O 的小demo。<br><a href="https://github.com/AT-Fieldless/my-flink-toy/blob/master/src/main/scala/FlinkAsyncIO.scala" target="_blank" rel="noopener">Async I/O demo</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://at-fieldless.github.io">thirteen</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://at-fieldless.github.io/2019/11/12/Flink-Async-I-O/">https://at-fieldless.github.io/2019/11/12/Flink-Async-I-O/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/Flink/">Flink</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2020/01/01/《Streaming-Systems》——-The-What-Where-When-and-How-of-Data-Processing/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">《Streaming Systems》—— The What, Where, When, and How of Data Processing</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2019/10/04/《Streaming-Systems》之《Streaming-101》/">
        <span class="next-text nav-default">《Streaming Systems》之《Streaming 101》</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:AT-Fieldless@outlook.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/AT-Fieldless" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">thirteen</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
