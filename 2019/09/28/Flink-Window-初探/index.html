<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Flink Window 初探"><meta name="keywords" content="Flink, Mr.Thirteen's blog"><link rel="alternate" href="/default" title="Mr.Thirteen's blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="https://at-fieldless.github.io/2019/09/28/Flink-Window-初探/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":"app_id:Ft6e3NGMakjJA8863I2S0Njs-gzGzoHsz app_key:0FzGh29Jey21Jw3XXnTI4TvJ","toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>Flink Window 初探 - Mr.Thirteen's blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Mr.Thirteen's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Mr.Thirteen's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Flink Window 初探
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-28
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是-Window"><span class="toc-text">什么是 Window ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-的种类"><span class="toc-text">Window 的种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-的设计理念"><span class="toc-text">Window 的设计理念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-示例"><span class="toc-text">Window 示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-源码解析"><span class="toc-text">Window 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Window-Assigner"><span class="toc-text">Window Assigner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Window-State"><span class="toc-text">Window State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trigger"><span class="toc-text">Trigger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Window-Operator-processElement方法"><span class="toc-text">Window Operator processElement方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当-Watermark-到来时"><span class="toc-text">当 Watermark 到来时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Window-Operator-onEventTime方法"><span class="toc-text">Window Operator onEventTime方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册清理窗口"><span class="toc-text">注册清理窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>在这篇文章中，我会谈谈在 Flink 中 Window 是什么，再以一个简单的例子分析一下 Window 的源码。</p>
<p>注：本文的代码基于Flink 1.9.0，且源码只涉及 TumblingEventTimeWindow</p>
<a id="more"></a>
<h2 id="什么是-Window"><a href="#什么是-Window" class="headerlink" title="什么是 Window ?"></a>什么是 Window ?</h2><p>想象一个场景，有一个不停在发送整数的数据源，如果我们想要计算它发出的数据总和，该怎么做呢？很简单，初始化总和为0，每来一个数，总和就加上这个数并输出即可。但问题是现实情况往往需要我们对一个时间范围的数据进行求和，比如下午1点到3点的数据总和为多少？为了解决这个问题， Flink 引入了 Window 的概念。</p>
<h2 id="Window-的种类"><a href="#Window-的种类" class="headerlink" title="Window 的种类"></a>Window 的种类</h2><p>Flink 把窗口分为两大类，一类是基于时间的 Time Window，还有一类是基于数据的 Count Window，每种 Window 又可以简单分为 Tumbling Window(翻滚窗口)和 Sliding Window（滚动窗口）。接下来将会以 Tumbling Time Window 为例写一个小程序，并分析一下 Flink 中的 Window 机制是如何运作的。</p>
<h2 id="Window-的设计理念"><a href="#Window-的设计理念" class="headerlink" title="Window 的设计理念"></a>Window 的设计理念</h2><p>下图是 Flink 官方博客的一张图，从中我们可以看到 Window 是如何设计并如何运作的。<br><img src="https://flink.apache.org/img/blog/window-intro/window-mechanics.png" alt="alt 属性文本"></p>
<p>首先第一步每条来到 Window Operator 的数据都会通过 Window Assigner 来指定它到哪个 Window 中，每个 Window 都会自带一个 Trigger 来决定什么时候对这个 Window 中的数据进行 Fire（对数据进行计算） 还是 Purge （删除 Window 和它包含的数据）。当 Window 处于 Fire 时，如果定义了 Evictor 那么数据会先被 Evictor 处理，Evictor 可以从头删除部分数据，再把数据传送到下一步的 Evaluation Function 。而如果没定义 Evictor ，数据就会完整得传送给 Evaluation Function 进行计算。当 Evaluation Function 对这个 Window 里的数据算完并把结果发送到下游算子时，这次的 Window 算子就算结束了。</p>
<h2 id="Window-示例"><a href="#Window-示例" class="headerlink" title="Window 示例"></a>Window 示例</h2><p>假设用户在页面中所看到的每一件商品都是由某个算法推荐出来的，我们想看看在某个时间范围内每个算法被点击的总次数。这个程序将会实现每五分钟统计一次每个算法被点击的次数。</p>
<p>首先定义 Flink 接收的数据格式,以及数据源的数据内容</p>
 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgoClick</span>(<span class="params">algoName: <span class="type">String</span>, ts: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//用集合元素作为数据源，并用当前的系统时间作为时间戳</span></span></span><br><span class="line"><span class="class"> <span class="title">def</span> <span class="title">init</span>(<span class="params"></span>)</span>: <span class="type">List</span>[<span class="type">AlgoClick</span>] = &#123;</span><br><span class="line">   <span class="keyword">val</span> algoClick1 = <span class="type">AlgoClick</span>(<span class="string">"algo1"</span>, <span class="type">System</span>.currentTimeMillis())</span><br><span class="line">   <span class="keyword">val</span> algoClick2 = <span class="type">AlgoClick</span>(<span class="string">"algo2"</span>, <span class="type">System</span>.currentTimeMillis())</span><br><span class="line">   <span class="keyword">val</span> algoClick3 = <span class="type">AlgoClick</span>(<span class="string">"algo2"</span>, <span class="type">System</span>.currentTimeMillis())</span><br><span class="line">   <span class="keyword">val</span> algoClickList = <span class="type">List</span>(algoClick1, algoClick2, algoClick3)</span><br><span class="line">   algoClickList</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>接着定义 Window Assigner</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStampExtractor</span> <span class="keyword">extends</span> <span class="title">AssignerWithPeriodicWatermarks</span>[<span class="type">AlgoClick</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Watermark</span>(<span class="type">System</span>.currentTimeMillis())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">AlgoClick</span>, previousElementTimestamp: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">    element.ts</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后定义两个时间处理函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcessFunction</span> <span class="keyword">extends</span> <span class="title">AggregateFunction</span>[<span class="type">AlgoClick</span>, <span class="type">Long</span>, <span class="type">Long</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createAccumulator</span></span>(): <span class="type">Long</span> = <span class="number">0</span>L</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(value: <span class="type">AlgoClick</span>, accumulator: <span class="type">Long</span>): <span class="type">Long</span> = accumulator+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getResult</span></span>(accumulator: <span class="type">Long</span>): <span class="type">Long</span> = accumulator</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(a: <span class="type">Long</span>, b: <span class="type">Long</span>): <span class="type">Long</span> = a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcessWindowFunction</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>[<span class="type">Long</span>, (<span class="type">String</span>, <span class="type">Long</span>), <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(key: <span class="type">String</span>, context: <span class="type">Context</span>, elements: <span class="type">Iterable</span>[<span class="type">Long</span>], out: <span class="type">Collector</span>[(<span class="type">String</span>, <span class="type">Long</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> algoName = key</span><br><span class="line">        <span class="keyword">val</span> count = elements.iterator.next</span><br><span class="line">        out.collect(<span class="keyword">new</span> <span class="type">Tuple2</span>[<span class="type">String</span>, <span class="type">Long</span>](algoName, count))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.createLocalEnvironment()</span><br><span class="line"></span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line">    env.fromCollection(init()).assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">TimeStampExtractor</span>)</span><br><span class="line">      .keyBy(_.algoName)</span><br><span class="line">      .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.minutes(<span class="number">5</span>L)))</span><br><span class="line">      .aggregate(<span class="keyword">new</span> <span class="type">MyProcessFunction</span>, <span class="keyword">new</span> <span class="type">MyProcessWindowFunction</span>)</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Window-源码解析"><a href="#Window-源码解析" class="headerlink" title="Window 源码解析"></a>Window 源码解析</h2><p>接下来依次会看 Window Assigner和Trigger的源码，最后再把它们两个结合到 Window Operator 之中一起分析。</p>
<h3 id="Window-Assigner"><a href="#Window-Assigner" class="headerlink" title="Window Assigner"></a>Window Assigner</h3><p>先看下每个元素在进入到 Window Operator 之后是如何分配到自己相应的 Window 的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Collection&lt;TimeWindow&gt; <span class="title">assignWindows</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, WindowAssignerContext context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (timestamp &gt; Long.MIN_VALUE) &#123;</span><br><span class="line">			<span class="comment">// Long.MIN_VALUE is currently assigned when no timestamp is present</span></span><br><span class="line">			<span class="keyword">long</span> start = TimeWindow.getWindowStartWithOffset(timestamp, offset, size);</span><br><span class="line">			<span class="keyword">return</span> Collections.singletonList(<span class="keyword">new</span> TimeWindow(start, start + size));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Record has Long.MIN_VALUE timestamp (= no timestamp marker). "</span> +</span><br><span class="line">					<span class="string">"Is the time characteristic set to 'ProcessingTime', or did you forget to call "</span> +</span><br><span class="line">					<span class="string">"'DataStream.assignTimestampsAndWatermarks(...)'?"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getWindowStartWithOffset</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">long</span> offset, <span class="keyword">long</span> windowSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> timestamp - (timestamp - offset + windowSize) % windowSize;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里说一下 getWindowStartWithOffset 方法，这个方法让返回的开始时间戳能够被 windowSize 整除。按照我们这个示例，这么做的话所开的窗口就会是 00：00 ~ 00：05， 00：05 ~ 00：10,所以一条时间戳是 00：07的数据就可以放到00：05 ~ 00：10的窗口之中。</p>
<h3 id="Window-State"><a href="#Window-State" class="headerlink" title="Window State"></a>Window State</h3><p>当元素分配到属于自己的 Window 之后，Window Operator 对应的 Window State 就会把这个 Window 进行保存，可能是内存也可能持久化到磁盘中，因为 state 的内容和本文关系不大，所以就不在这里详述了，只是提一下，之前定义的 AggregateFunction 中生成的 ACC 就会通过这步保存到 state 中。</p>
<h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>之后，这个元素就会触发一次 triggerContext。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onElement</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, TimeWindow window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (window.maxTimestamp() &lt;= ctx.getCurrentWatermark()) &#123;</span><br><span class="line">			<span class="comment">// if the watermark is already past the window fire immediately</span></span><br><span class="line">			<span class="keyword">return</span> TriggerResult.FIRE;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ctx.registerEventTimeTimer(window.maxTimestamp());</span><br><span class="line">			<span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果当前窗口的最大时间戳小于 triggerContext 的 watermark ,说明当前窗口的元素都已经被接收完毕（初始的 Watermark 是Long.MIN_VALUE），可以对这个窗口进行运算了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emitWindowContents</span><span class="params">(W window, ACC contents)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	timestampedCollector.setAbsoluteTimestamp(window.maxTimestamp());</span><br><span class="line">	processContext.window = window;</span><br><span class="line">	userFunction.process(triggerContext.key, window, processContext, contents, timestampedCollector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就调用了之前定义的 MyProcessWindowFunction 。（更准确得说其实是 process 里面的方法调用的）</p>
<p>而如果还没到计算的时候，就需要把这个 Window 的信息记录下来了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//调用 internalTimerService 类进行注册</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">	internalTimerService.registerEventTimeTimer(window, time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerEventTimeTimer</span><span class="params">(N namespace, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">	eventTimeTimersQueue.add(<span class="keyword">new</span> TimerHeapInternalTimer&lt;&gt;(time, (K) keyContext.getCurrentKey(), namespace));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the element to the queue. In contrast to the superclass and to maintain set semantics, this happens only if</span></span><br><span class="line"><span class="comment"> * no such element is already contained (determined by &#123;<span class="doctag">@link</span> #equals(Object)&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;code&gt;true&lt;/code&gt; if the operation changed the head element or if is it unclear if the head element changed.</span></span><br><span class="line"><span class="comment"> * Only returns &lt;code&gt;false&lt;/code&gt; iff the head element was not changed by this operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(@Nonnull T element)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getDedupMapForElement(element).putIfAbsent(element, element) == <span class="keyword">null</span> &amp;&amp; <span class="keyword">super</span>.add(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的注释可以看出最终这个 Window 被保存到一个队列里而且这个队列还是一个集合。</p>
<h3 id="Window-Operator-processElement方法"><a href="#Window-Operator-processElement方法" class="headerlink" title="Window Operator processElement方法"></a>Window Operator processElement方法</h3><p>Window Operator processElement方法基本就是按照之前讲的顺序执行的，在这里省略了部分 Session Window 的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(StreamRecord&lt;IN&gt; element)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//给当前元素分配一个 window</span></span><br><span class="line">  <span class="keyword">final</span> Collection&lt;W&gt; elementWindows = windowAssigner.assignWindows(</span><br><span class="line">    element.getValue(), element.getTimestamp(), windowAssignerContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> K key = <span class="keyword">this</span>.&lt;K&gt;getKeyedStateBackend().getCurrentKey();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在 state 中保存信息</span></span><br><span class="line">   windowState.setCurrentNamespace(window);</span><br><span class="line">   windowState.add(element.getValue());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置 trigger 信息</span></span><br><span class="line">   triggerContext.key = key;</span><br><span class="line">   triggerContext.window = window;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//得到本次 trigger的结果</span></span><br><span class="line">   TriggerResult triggerResult = triggerContext.onElement(element);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (triggerResult.isFire()) &#123;</span><br><span class="line">     ACC contents = windowState.get();</span><br><span class="line">     <span class="keyword">if</span> (contents == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     emitWindowContents(window, contents);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (triggerResult.isPurge()) &#123;</span><br><span class="line">     windowState.clear();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//给这次 window 注册一个过期清理窗口</span></span><br><span class="line">   registerCleanupTimer(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="当-Watermark-到来时"><a href="#当-Watermark-到来时" class="headerlink" title="当 Watermark 到来时"></a>当 Watermark 到来时</h3><p>当 Watermark 到来时，我们可以认为一部分窗口的所需的数据已经全部到来，可以触发计算了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">advanceWatermark</span><span class="params">(<span class="keyword">long</span> time)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//这里的 time 就是 watermark 中的时间</span></span><br><span class="line">		currentWatermark = time;</span><br><span class="line"></span><br><span class="line">		InternalTimer&lt;K, N&gt; timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把所有在队列里窗口最大时间小于 watermark 时间的窗口全部拿出来</span></span><br><span class="line">		<span class="keyword">while</span> ((timer = eventTimeTimersQueue.peek()) != <span class="keyword">null</span> &amp;&amp; timer.getTimestamp() &lt;= time) &#123;</span><br><span class="line">			eventTimeTimersQueue.poll();</span><br><span class="line">			keyContext.setCurrentKey(timer.getKey());</span><br><span class="line">			triggerTarget.onEventTime(timer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Window-Operator-onEventTime方法"><a href="#Window-Operator-onEventTime方法" class="headerlink" title="Window Operator onEventTime方法"></a>Window Operator onEventTime方法</h3><p>上一步 advanceWatermark 方法具体调用的就是 Window Operator onEventTime方法。同样的，这里我还是删掉了部分关于 Session Window 的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventTime</span><span class="params">(InternalTimer&lt;K, W&gt; timer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		triggerContext.key = timer.getKey();</span><br><span class="line">		triggerContext.window = timer.getNamespace();</span><br><span class="line"></span><br><span class="line">			windowState.setCurrentNamespace(triggerContext.window);</span><br><span class="line">			mergingWindows = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		TriggerResult triggerResult = triggerContext.onEventTime(timer.getTimestamp());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (triggerResult.isFire()) &#123;</span><br><span class="line">			ACC contents = windowState.get();</span><br><span class="line">			<span class="keyword">if</span> (contents != <span class="keyword">null</span>) &#123;</span><br><span class="line">				emitWindowContents(triggerContext.window, contents);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (triggerResult.isPurge()) &#123;</span><br><span class="line">			windowState.clear();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是之前注册的过期清理窗口，进行状态清理</span></span><br><span class="line">		<span class="keyword">if</span> (windowAssigner.isEventTime() &amp;&amp; isCleanupTime(triggerContext.window, timer.getTimestamp())) &#123;</span><br><span class="line">			clearAllState(triggerContext.window, windowState, mergingWindows);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出触发计算的代码其实和 processElement 方法差不多。然而最后有一个触发状态清理的运算，这个就是和 processElement 最后注册一个清理窗口相呼应的。我们下面具体看一下是怎么实现的</p>
<h3 id="注册清理窗口"><a href="#注册清理窗口" class="headerlink" title="注册清理窗口"></a>注册清理窗口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerCleanupTimer</span><span class="params">(W window)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> cleanupTime = cleanupTime(window);</span><br><span class="line">	<span class="keyword">if</span> (cleanupTime == Long.MAX_VALUE) &#123;</span><br><span class="line">		<span class="comment">// don't set a GC timer for "end of time"</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (windowAssigner.isEventTime()) &#123;</span><br><span class="line">		triggerContext.registerEventTimeTimer(cleanupTime);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		triggerContext.registerProcessingTimeTimer(cleanupTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">cleanupTime</span><span class="params">(W window)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (windowAssigner.isEventTime()) &#123;</span><br><span class="line">		<span class="keyword">long</span> cleanupTime = window.maxTimestamp() + allowedLateness;</span><br><span class="line">		<span class="keyword">return</span> cleanupTime &gt;= window.maxTimestamp() ? cleanupTime : Long.MAX_VALUE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> window.maxTimestamp();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据源码可以看出这个清理窗口的时间就是当前 window 的最大时间戳再加上用户定义的 allowedLateness 也就是最大允许延迟时间，由于本示例中没有定义这个值，该值也就默认为0，所以每个窗口在触发运算的时候也将执行一次清理状态的操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文先从 Window 的定义开始，简单介绍了下什么是 Window 以及 Window 常见的种类，然后根据官博的设计图，说明了 Window 的总运行流程。之后通过一个实例并结合 Window 源码详述了在 EventTime 和 Tumbling Window 情况下，整个 Window Operator 的内部代码原理。希望能对大家有所帮助。</p>
<p>本文代码地址：<a href="https://github.com/AT-Fieldless/my-flink-toy/blob/master/src/main/scala/FlinkWindowCount.scala" target="_blank" rel="noopener">https://github.com/AT-Fieldless/my-flink-toy/blob/master/src/main/scala/FlinkWindowCount.scala</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://at-fieldless.github.io">thirteen</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://at-fieldless.github.io/2019/09/28/Flink-Window-初探/">https://at-fieldless.github.io/2019/09/28/Flink-Window-初探/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/Flink/">Flink</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/10/04/《Streaming-Systems》之《Streaming-101》/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">《Streaming Systems》之《Streaming 101》</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2019/02/17/程序次序规则/">
        <span class="next-text nav-default">程序次序规则</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:AT-Fieldless@outlook.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/AT-Fieldless" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">thirteen</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
